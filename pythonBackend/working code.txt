from fastapi import FastAPI, Request, HTTPException, Depends, status
from fastapi.middleware.cors import CORSMiddleware
from fastapi.security import OAuth2PasswordBearer, OAuth2PasswordRequestForm
import os
import joblib
import json
import pandas as pd
import sqlite3
from pydantic import BaseModel
from datetime import datetime, timedelta
from typing import List, Optional
import google.generativeai as genai
import jwt
from passlib.context import CryptContext
from dotenv import load_dotenv

load_dotenv()

app = FastAPI()

# CORS configuration
app.add_middleware(
    CORSMiddleware,
    allow_origins=["*"],
    allow_credentials=True,
    allow_methods=["*"],
    allow_headers=["*"],
)

# JWT configuration
SECRET_KEY = os.getenv("SECRET_KEY", "your-secret-key")
ALGORITHM = "HS256"
ACCESS_TOKEN_EXPIRE_MINUTES = 30

# Password hashing
pwd_context = CryptContext(schemes=["bcrypt"], deprecated="auto")

# OAuth2 scheme
oauth2_scheme = OAuth2PasswordBearer(tokenUrl="login")

# SQLite database setup
def init_db():
    conn = sqlite3.connect("ayurvaid.db")
    cursor = conn.cursor()
    cursor.execute("""
        CREATE TABLE IF NOT EXISTS users (
            id INTEGER PRIMARY KEY AUTOINCREMENT,
            username TEXT UNIQUE NOT NULL,
            email TEXT UNIQUE NOT NULL,
            hashed_password TEXT NOT NULL,
            created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
        )
    """)
    cursor.execute("""
        CREATE TABLE IF NOT EXISTS chats (
            id INTEGER PRIMARY KEY AUTOINCREMENT,
            user_id INTEGER,
            sender TEXT NOT NULL,
            message TEXT NOT NULL,
            timestamp TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
            FOREIGN KEY (user_id) REFERENCES users (id)
        )
    """)
    conn.commit()
    conn.close()

init_db()

# Pydantic models
class InputData(BaseModel):
    user_input: str

class UserCreate(BaseModel):
    username: str
    email: str
    password: str

class UserLogin(BaseModel):
    username: str
    password: str

class ChatMessage(BaseModel):
    sender: str
    message: str
    timestamp: str

# Utility functions
def loadDataFromJson():
    try:
        with open("data.json", "r") as f:
            loaded_data = json.load(f)
        return (
            loaded_data["systemPrompt"],
            loaded_data["symptom_master_list"],
            loaded_data["ayurvedicHash"],
            loaded_data["ayurvedicSystemPrompt"],
            loaded_data.get("aryuvedicMedicineData", {}),
            loaded_data["finalResponseSystemPrompt"],
            loaded_data.get("conversationalPrompt", "Respond conversationally to general greetings or questions (e.g., 'hi', 'how are you') with a friendly reply like 'Hello! How can I assist you today?'")
        )
    except Exception as e:
        raise ValueError(f"Failed to load data.json: {str(e)}")

def setupGemini(systemPrompt):
    GENAI_APIKEY = os.getenv("GENAI_APIKEY")
    if not GENAI_APIKEY:
        raise ValueError("Please set the GENAI_APIKEY environment variable.")
    GENAI_MODEL = os.getenv("GENAI_MODEL")
    if not GENAI_MODEL:
        raise ValueError("Please set the GENAI_MODEL environment variable.")
    
    genai.configure(api_key=GENAI_APIKEY)
    model = genai.GenerativeModel(model_name=GENAI_MODEL, system_instruction=systemPrompt)
    chat = model.start_chat()
    return chat

def askGemini(prompt: str, geminiChat):
    try:
        response = geminiChat.send_message(prompt)
        return response.text
    except Exception as e:
        raise ValueError(f"Gemini API error: {str(e)}")

def convertUserResponseToDatasetStructure(input_symptoms, symptom_master_list):
    if isinstance(input_symptoms, str):
        cleaned_input = input_symptoms.replace("```json", "").replace("```", "").strip()
        try:
            input_symptoms = json.loads(cleaned_input)
        except json.JSONDecodeError:
            input_symptoms = [s.strip() for s in cleaned_input.split(",") if s.strip()]
    elif not isinstance(input_symptoms, list):
        input_symptoms = [str(input_symptoms)]

    input_symptoms = [s.lower().strip() for s in input_symptoms]
    symptom_master_list = [s.lower().strip() for s in symptom_master_list]

    binary_vector = [1 if symptom in input_symptoms else 0 for symptom in symptom_master_list]
    print(f"Normalized symptoms: {input_symptoms}")
    print(f"Binary vector: {binary_vector}")
    return binary_vector

def predict_disease(input_list, model_path='disease_lr_model_with_encoder.joblib'):
    try:
        bundle = joblib.load(model_path)
        model = bundle['model']
        encoder = bundle['label_encoder']
        input_df = pd.DataFrame([input_list], columns=model.estimators_[0].feature_names_in_)
        if sum(input_list) == 0:
            return "No disease predicted (no symptoms matched)"
        pred_encoded = model.predict(input_df)
        prediction = encoder.inverse_transform(pred_encoded)[0]
        print(f"Model input: {input_list}")
        print(f"Model prediction: {prediction}")
        return prediction
    except Exception as e:
        raise ValueError(f"Prediction error: {str(e)}")

def classifyDisease(disease: str, symptoms, geminiChat):
    userPrompt = f"Diseases: {disease}\nSymptoms: {symptoms}"
    return askGemini(userPrompt, geminiChat).strip()

def getKeyValuesfromMedicineJson(jsonData, key: str):
    return jsonData.get(key, [])

def listCleaner(response):
    if not isinstance(response, list):
        cleaned = response.replace("`", "").replace("json", "").strip()
        try:
            return json.loads(cleaned) if cleaned.startswith("[") else cleaned.split(",")
        except:
            return [cleaned]
    return response

# Authentication utilities
def verify_password(plain_password, hashed_password):
    return pwd_context.verify(plain_password, hashed_password)

def get_password_hash(password):
    return pwd_context.hash(password)

def create_access_token(data: dict):
    to_encode = data.copy()
    expire = datetime.utcnow() + timedelta(minutes=ACCESS_TOKEN_EXPIRE_MINUTES)
    to_encode.update({"exp": expire})
    encoded_jwt = jwt.encode(to_encode, SECRET_KEY, algorithm=ALGORITHM)
    return encoded_jwt

async def get_current_user(token: str = Depends(oauth2_scheme)):
    try:
        payload = jwt.decode(token, SECRET_KEY, algorithms=[ALGORITHM])
        username: str = payload.get("sub")
        if username is None:
            raise HTTPException(status_code=401, detail="Invalid token")
    except jwt.PyJWTError:
        raise HTTPException(status_code=401, detail="Invalid token")
    
    conn = sqlite3.connect("ayurvaid.db")
    cursor = conn.cursor()
    cursor.execute("SELECT id, username, email FROM users WHERE username = ?", (username,))
    user = cursor.fetchone()
    conn.close()
    
    if user is None:
        raise HTTPException(status_code=401, detail="User not found")
    return {"id": user[0], "username": user[1], "email": user[2]}

# Static content endpoints
@app.get("/about")
def get_about():
    return {
        "title": "About Ayurvaid",
        "content": (
            "Ayurvaid blends ancient Ayurvedic wisdom with cutting-edge AI to offer personalized health solutions. "
            "Our platform empowers users to understand their symptoms and discover natural remedies."
        ),
        "vision": "Holistic wellness for all through technology and tradition."
    }

@app.get("/services")
def get_services():
    return {
        "title": "Our Services",
        "services": [
            {"name": "Symptom Analysis", "description": "AI-driven diagnosis based on your symptoms."},
            {"name": "Ayurvedic Remedies", "description": "Natural treatments tailored to your condition."},
            {"name": "Health Guidance", "description": "Daily tips for a balanced lifestyle."}
        ]
    }

@app.get("/contact")
def get_contact():
    return {
        "title": "Contact Us",
        "email": "support@ayurvaid.com",
        "phone": "+91-123-456-7890",
        "address": "123 Wellness Lane, Ayur City, India"
    }

# Authentication endpoints
@app.post("/signup")
def signup(user: UserCreate):
    conn = sqlite3.connect("ayurvaid.db")
    cursor = conn.cursor()
    
    cursor.execute("SELECT id FROM users WHERE username = ? OR email = ?", (user.username, user.email))
    if cursor.fetchone():
        conn.close()
        raise HTTPException(status_code=400, detail="Username or email already exists")
    
    hashed_password = get_password_hash(user.password)
    try:
        cursor.execute(
            "INSERT INTO users (username, email, hashed_password) VALUES (?, ?, ?)",
            (user.username, user.email, hashed_password)
        )
        conn.commit()
    except Exception as e:
        conn.close()
        raise HTTPException(status_code=500, detail=f"Error creating user: {str(e)}")
    
    conn.close()
    return {"message": "User created successfully"}

@app.post("/login")
def login(form_data: OAuth2PasswordRequestForm = Depends()):
    conn = sqlite3.connect("ayurvaid.db")
    cursor = conn.cursor()
    
    cursor.execute("SELECT id, username, hashed_password FROM users WHERE username = ?", (form_data.username,))
    user = cursor.fetchone()
    conn.close()
    
    if not user or not verify_password(form_data.password, user[2]):
        raise HTTPException(status_code=401, detail="Invalid username or password")
    
    access_token = create_access_token(data={"sub": user[1]})
    return {"access_token": access_token, "token_type": "bearer"}

# Updated predict endpoint
@app.post("/predict")
async def predict(data: InputData, current_user: dict = Depends(get_current_user)):
    try:
        systemPrompt, symptom_master_list, ayurvedicHash, ayurvedicSystemPrompt, aryuvedicMedicineData, finalResponseSystemPrompt, conversationalPrompt = loadDataFromJson()
    except Exception as e:
        return {"error": f"Error loading data: {str(e)}"}
    
    try:
        geminiIntentChat = setupGemini("Determine if the input describes health symptoms (e.g., 'I have a fever') or is a general greeting/question (e.g., 'hi', 'how are you'). Return 'symptoms' or 'general'.")
        geminiConversationalChat = setupGemini(conversationalPrompt)
        geminiDiseaseChat = setupGemini(systemPrompt)
        geminiAryuvedicChat = setupGemini(ayurvedicSystemPrompt)
        geminiFinalResponseChat = setupGemini(finalResponseSystemPrompt)
    except Exception as e:
        return {"error": f"Error setting up Gemini: {str(e)}"}
    
    # Save user message
    conn = sqlite3.connect("ayurvaid.db")
    cursor = conn.cursor()
    cursor.execute(
        "INSERT INTO chats (user_id, sender, message) VALUES (?, ?, ?)",
        (current_user["id"], "user", data.user_input)
    )
    conn.commit()
    
    try:
        # Check intent
        intent = askGemini(data.user_input, geminiIntentChat).strip().lower()
        print(f"User input: {data.user_input}")
        print(f"Detected intent: {intent}")
        
        if intent == "general":
            # Handle conversational response
            finalResponse = askGemini(data.user_input, geminiConversationalChat)
            print(f"Conversational response: {finalResponse}")
        else:
            # Proceed with disease prediction
            symptoms = askGemini(data.user_input, geminiDiseaseChat)
            print(f"Extracted symptoms: {symptoms}")
            binary_vector = convertUserResponseToDatasetStructure(symptoms, symptom_master_list)
            if sum(binary_vector) == 0:
                print("Warning: Binary vector is all zeros, no symptoms matched.")
                finalResponse = "I couldn't identify any specific symptoms. Could you describe your health concerns in more detail?"
            else:
                diseasesPredicted = predict_disease(binary_vector)
                print(f"Predicted disease: {diseasesPredicted}")
                ayurvedicRog = classifyDisease(diseasesPredicted, symptoms, geminiAryuvedicChat).strip()
                print(f"Ayurvedic disease: {ayurvedicRog}")
                
                listOfAyurvedicMedication = []
                try:
                    listOfAyurvedicMedication = getKeyValuesfromMedicineJson(aryuvedicMedicineData, ayurvedicRog)
                    if not isinstance(listOfAyurvedicMedication, list):
                        listOfAyurvedicMedication = listCleaner(listOfAyurvedicMedication)
                except Exception as e:
                    listOfAyurvedicMedication = ["No specific Ayurvedic medications found."]
                print(f"Ayurvedic medications: {listOfAyurvedicMedication}")
                
                userMedicalData = (
                    f"Disease Name: {diseasesPredicted}\n"
                    f"Symptoms: {symptoms}\n"
                    f"Ayurvedic Disease Name: {ayurvedicRog}\n"
                    f"Ayurvedic Medications List: {listOfAyurvedicMedication}"
                )
                print(f"User medical data: {userMedicalData}")
                
                finalResponse = askGemini(userMedicalData, geminiFinalResponseChat)
                print(f"Final response: {finalResponse}")
        
        # Save bot response
        cursor.execute(
            "INSERT INTO chats (user_id, sender, message) VALUES (?, ?, ?)",
            (current_user["id"], "bot", finalResponse)
        )
        conn.commit()
        
        return {"response": finalResponse}
    
    except Exception as e:
        return {"error": f"Error processing request: {str(e)}"}
    
    finally:
        conn.close()

# Chat history endpoint
@app.get("/chats", response_model=List[ChatMessage])
async def get_chat_history(current_user: dict = Depends(get_current_user)):
    conn = sqlite3.connect("ayurvaid.db")
    cursor = conn.cursor()
    cursor.execute(
        "SELECT sender, message, timestamp FROM chats WHERE user_id = ? ORDER BY timestamp ASC",
        (current_user["id"],)
    )
    chats = cursor.fetchall()
    conn.close()
    
    return [
        {"sender": chat[0], "message": chat[1], "timestamp": chat[2]}
        for chat in chats
    ]