from fastapi import FastAPI, Request, HTTPException, Depends, status
from fastapi.middleware.cors import CORSMiddleware
from fastapi.security import OAuth2PasswordBearer, OAuth2PasswordRequestForm
import os
import joblib
import json
import pandas as pd
import sqlite3
from pydantic import BaseModel
from datetime import datetime, timedelta
from typing import List, Optional
import google.generativeai as genai
import jwt
from passlib.context import CryptContext
from dotenv import load_dotenv

load_dotenv()

app = FastAPI()

# CORS configuration
app.add_middleware(
    CORSMiddleware,
    allow_origins=["*"],
    allow_credentials=True,
    allow_methods=["*"],
    allow_headers=["*"],
)

# JWT configuration
SECRET_KEY = os.getenv("SECRET_KEY", "your-secret-key")
ALGORITHM = "HS256"
ACCESS_TOKEN_EXPIRE_MINUTES = 30

# Password hashing
pwd_context = CryptContext(schemes=["bcrypt"], deprecated="auto")

# OAuth2 scheme
oauth2_scheme = OAuth2PasswordBearer(tokenUrl="login")

# SQLite database setup
def init_db():
    conn = sqlite3.connect("ayurvaid.db")
    cursor = conn.cursor()
    cursor.execute("""
        CREATE TABLE IF NOT EXISTS users (
            id INTEGER PRIMARY KEY AUTOINCREMENT,
            username TEXT UNIQUE NOT NULL,
            email TEXT UNIQUE NOT NULL,
            hashed_password TEXT NOT NULL,
            created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
        )
    """)
    cursor.execute("""
        CREATE TABLE IF NOT EXISTS user_profiles (
            user_id INTEGER PRIMARY KEY,
            age INTEGER,
            gender TEXT,
            updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
            FOREIGN KEY (user_id) REFERENCES users (id)
        )
    """)
    cursor.execute("""
        CREATE TABLE IF NOT EXISTS chats (
            id INTEGER PRIMARY KEY AUTOINCREMENT,
            user_id INTEGER,
            sender TEXT NOT NULL,
            message TEXT NOT NULL,
            timestamp TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
            FOREIGN KEY (user_id) REFERENCES users (id)
        )
    """)
    cursor.execute("""
        CREATE TABLE IF NOT EXISTS pending_chats (
            id INTEGER PRIMARY KEY AUTOINCREMENT,
            user_id INTEGER,
            symptoms TEXT NOT NULL,
            created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
            FOREIGN KEY (user_id) REFERENCES users (id)
        )
    """)
    conn.commit()
    conn.close()

init_db()

# Pydantic models
class InputData(BaseModel):
    user_input: str

class UserCreate(BaseModel):
    username: str
    email: str
    password: str

class UserLogin(BaseModel):
    username: str
    password: str

class ChatMessage(BaseModel):
    sender: str
    message: str
    timestamp: str

# Utility functions
def loadDataFromJson():
    try:
        with open("data.json", "r") as f:
            loaded_data = json.load(f)
        return (
            loaded_data["systemPrompt"],
            loaded_data["symptom_master_list"],
            loaded_data["ayurvedicHash"],
            loaded_data["ayurvedicSystemPrompt"],
            loaded_data.get("aryuvedicMedicineData", {}),
            loaded_data["finalResponseSystemPrompt"],
            loaded_data.get("conversationalPrompt", "Respond conversationally..."),
            loaded_data.get("intentPrompt", "Classify the input..."),
            loaded_data.get("adjustmentPrompt", "Given a disease...")
        )
    except Exception as e:
        raise ValueError(f"Failed to load data.json: {str(e)}")

def setupGemini(systemPrompt):
    GENAI_APIKEY = os.getenv("GENAI_APIKEY")
    if not GENAI_APIKEY:
        raise ValueError("Please set the GENAI_APIKEY environment variable.")
    GENAI_MODEL = os.getenv("GENAI_MODEL")
    if not GENAI_MODEL:
        raise ValueError("Please set the GENAI_MODEL environment variable.")
    
    genai.configure(api_key=GENAI_APIKEY)
    model = genai.GenerativeModel(model_name=GENAI_MODEL, system_instruction=systemPrompt)
    chat = model.start_chat()
    return chat

def askGemini(prompt: str, geminiChat):
    try:
        response = geminiChat.send_message(prompt)
        raw_text = response.text.strip()
        # Remove backticks and "json" markers
        clean_text = raw_text.replace("```json", "").replace("```", "").strip()
        if not clean_text:
            raise ValueError("Empty response from Gemini")
        return clean_text
    except Exception as e:
        print(f"Gemini API error: {str(e)}")
        return '{"symptoms": [], "age": null, "gender": null}'  # Fallback JSON

def convertUserResponseToDatasetStructure(input_symptoms, symptom_master_list):
    if isinstance(input_symptoms, str):
        cleaned_input = input_symptoms.replace("```json", "").replace("```", "").strip()
        try:
            input_symptoms = json.loads(cleaned_input)
        except json.JSONDecodeError:
            input_symptoms = [s.strip() for s in cleaned_input.split(",") if s.strip()]
    elif not isinstance(input_symptoms, list):
        input_symptoms = [str(input_symptoms)]

    input_symptoms = [s.lower().strip() for s in input_symptoms]
    symptom_master_list = [s.lower().strip() for s in symptom_master_list]

    binary_vector = [1 if symptom in input_symptoms else 0 for symptom in symptom_master_list]
    unmatched_symptoms = [s for s in input_symptoms if s not in symptom_master_list]
    # print(f"Normalized symptoms: {input_symptoms}")
    # print(f"Unmatched symptoms: {unmatched_symptoms}")
    # print(f"Binary vector: {binary_vector}")
    return binary_vector
def predict_disease(input_list, model_path='disease_lr_model_with_encoder.joblib'):
    try:
        bundle = joblib.load(model_path)
        model = bundle['model']
        encoder = bundle['label_encoder']
        input_df = pd.DataFrame([input_list], columns=model.estimators_[0].feature_names_in_)
        if sum(input_list) == 0:
            return "No disease predicted (no symptoms matched)"
        pred_encoded = model.predict(input_df)
        prediction = encoder.inverse_transform(pred_encoded)[0]
        # print(f"Model input: {input_list}")
        print(f"Model prediction: {prediction}")
        return prediction
    except Exception as e:
        raise ValueError(f"Prediction error: {str(e)}")

def classifyDisease(disease: str, symptoms, geminiChat):
    userPrompt = f"Diseases: {disease}\nSymptoms: {symptoms}"
    return askGemini(userPrompt, geminiChat).strip()

def getKeyValuesfromMedicineJson(jsonData, key: str):
    return jsonData.get(key, [])

def listCleaner(response):
    if not isinstance(response, list):
        cleaned = response.replace("`", "").replace("json", "").strip()
        try:
            return json.loads(cleaned) if cleaned.startswith("[") else cleaned.split(",")
        except:
            return [cleaned]
    return response

def get_user_profile(user_id):
    conn = sqlite3.connect("ayurvaid.db")
    cursor = conn.cursor()
    cursor.execute("SELECT age, gender FROM user_profiles WHERE user_id = ?", (user_id,))
    profile = cursor.fetchone()
    conn.close()
    return {"age": profile[0], "gender": profile[1]} if profile else {"age": None, "gender": None}

def save_user_profile(user_id, age, gender):
    conn = sqlite3.connect("ayurvaid.db")
    cursor = conn.cursor()
    cursor.execute(
        "INSERT OR REPLACE INTO user_profiles (user_id, age, gender) VALUES (?, ?, ?)",
        (user_id, age, gender)
    )
    conn.commit()
    conn.close()

def save_pending_chat(user_id, symptoms):
    conn = sqlite3.connect("ayurvaid.db")
    cursor = conn.cursor()
    cursor.execute(
        "INSERT INTO pending_chats (user_id, symptoms) VALUES (?, ?)",
        (user_id, json.dumps(symptoms))
    )
    conn.commit()
    conn.close()

def get_pending_chat(user_id):
    conn = sqlite3.connect("ayurvaid.db")
    cursor = conn.cursor()
    cursor.execute("SELECT symptoms FROM pending_chats WHERE user_id = ? ORDER BY created_at DESC LIMIT 1", (user_id,))
    result = cursor.fetchone()
    if result:
        cursor.execute("DELETE FROM pending_chats WHERE user_id = ?", (user_id,))  # Clear after retrieval
        conn.commit()
    conn.close()
    return json.loads(result[0]) if result else None

# Authentication utilities
def verify_password(plain_password, hashed_password):
    return pwd_context.verify(plain_password, hashed_password)

def get_password_hash(password):
    return pwd_context.hash(password)

def create_access_token(data: dict):
    to_encode = data.copy()
    expire = datetime.utcnow() + timedelta(minutes=ACCESS_TOKEN_EXPIRE_MINUTES)
    to_encode.update({"exp": expire})
    encoded_jwt = jwt.encode(to_encode, SECRET_KEY, algorithm=ALGORITHM)
    return encoded_jwt

async def get_current_user(token: str = Depends(oauth2_scheme)):
    try:
        payload = jwt.decode(token, SECRET_KEY, algorithms=[ALGORITHM])
        username: str = payload.get("sub")
        if username is None:
            raise HTTPException(status_code=401, detail="Invalid token")
    except jwt.PyJWTError:
        raise HTTPException(status_code=401, detail="Invalid token")
    
    conn = sqlite3.connect("ayurvaid.db")
    cursor = conn.cursor()
    cursor.execute("SELECT id, username, email FROM users WHERE username = ?", (username,))
    user = cursor.fetchone()
    conn.close()
    
    if user is None:
        raise HTTPException(status_code=401, detail="User not found")
    return {"id": user[0], "username": user[1], "email": user[2]}

# Static content endpoints
@app.get("/about")
def get_about():
    return {
        "title": "About Ayurvaid",
        "content": "Ayurvaid blends ancient Ayurvedic wisdom with AI...",
        "vision": "Holistic wellness..."
    }

@app.get("/services")
def get_services():
    return {
        "title": "Our Services",
        "services": [
            {"name": "Symptom Analysis", "description": "AI-driven diagnosis..."},
            {"name": "Ayurvedic Remedies", "description": "Natural treatments..."},
            {"name": "Health Guidance", "description": "Daily tips..."}
        ]
    }

@app.get("/contact")
def get_contact():
    return {
        "title": "Contact Us",
        "email": "support@ayurvaid.com",
        "phone": "+91-123-456-7890",
        "address": "123 Wellness Lane, Ayur City, India"
    }

# Authentication endpoints
@app.post("/signup")
def signup(user: UserCreate):
    conn = sqlite3.connect("ayurvaid.db")
    cursor = conn.cursor()
    
    cursor.execute("SELECT id FROM users WHERE username = ? OR email = ?", (user.username, user.email))
    if cursor.fetchone():
        conn.close()
        raise HTTPException(status_code=400, detail="Username or email already exists")
    
    hashed_password = get_password_hash(user.password)
    try:
        cursor.execute(
            "INSERT INTO users (username, email, hashed_password) VALUES (?, ?, ?)",
            (user.username, user.email, hashed_password)
        )
        conn.commit()
    except Exception as e:
        conn.close()
        raise HTTPException(status_code=500, detail=f"Error creating user: {str(e)}")
    
    conn.close()
    return {"message": "User created successfully"}

@app.post("/login")
def login(form_data: OAuth2PasswordRequestForm = Depends()):
    conn = sqlite3.connect("ayurvaid.db")
    cursor = conn.cursor()
    
    cursor.execute("SELECT id, username, hashed_password FROM users WHERE username = ?", (form_data.username,))
    user = cursor.fetchone()
    conn.close()
    
    if not user or not verify_password(form_data.password, user[2]):
        raise HTTPException(status_code=401, detail="Invalid username or password")
    
    access_token = create_access_token(data={"sub": user[1]})
    return {"access_token": access_token, "token_type": "bearer"}

# Updated predict endpoint
@app.post("/predict")
async def predict(data: InputData, current_user: dict = Depends(get_current_user)):
    try:
        systemPrompt, symptom_master_list, ayurvedicHash, ayurvedicSystemPrompt, aryuvedicMedicineData, finalResponseSystemPrompt, conversationalPrompt, intentPrompt, adjustmentPrompt = loadDataFromJson()
    except Exception as e:
        return {"error": f"Error loading data: {str(e)}"}
    
    try:
        geminiIntentChat = setupGemini(intentPrompt)
        geminiConversationalChat = setupGemini(conversationalPrompt)
        geminiDiseaseChat = setupGemini(systemPrompt)
        geminiAryuvedicChat = setupGemini(ayurvedicSystemPrompt)
        geminiFinalResponseChat = setupGemini(finalResponseSystemPrompt)
        geminiAdjustmentChat = setupGemini(adjustmentPrompt)
    except Exception as e:
        return {"error": f"Error setting up Gemini: {str(e)}"}
    
    # Save user message
    conn = sqlite3.connect("ayurvaid.db")
    cursor = conn.cursor()
    cursor.execute(
        "INSERT INTO chats (user_id, sender, message) VALUES (?, ?, ?)",
        (current_user["id"], "user", data.user_input)
    )
    conn.commit()
    conn.close()
    
    try:
        # Check intent
        intent = askGemini(data.user_input, geminiIntentChat).strip().lower()
        print(f"User input: {data.user_input}")
        print(f"Detected intent: {intent}")
        
        if intent == "general":
            finalResponse = askGemini(data.user_input, geminiConversationalChat)
            print(f"Conversational response: {finalResponse}")
        elif intent == "age_gender":
            # Parse age/gender
            raw_response = askGemini(data.user_input, geminiDiseaseChat)
            print(f"Raw Gemini response (age_gender): {raw_response}")
            try:
                parsed_data = json.loads(raw_response)
                if not isinstance(parsed_data, dict):
                    raise ValueError("Invalid JSON structure")
            except (json.JSONDecodeError, ValueError) as e:
                print(f"JSON parsing error (age_gender): {str(e)}")
                finalResponse = "I couldn’t process that input. Could you clarify your age and gender?"
                parsed_data = {"symptoms": [], "age": None, "gender": None}
            
            age = parsed_data.get("age")
            gender = parsed_data.get("gender")
            if age is not None or gender is not None:
                save_user_profile(current_user["id"], age, gender)
                print(f"Saved profile: age={age}, gender={gender}")
            
            # Check for pending symptoms
            pending_symptoms = get_pending_chat(current_user["id"])
            if pending_symptoms:
                binary_vector = convertUserResponseToDatasetStructure(pending_symptoms, symptom_master_list)
                print(f"Pending symptoms binary vector: {binary_vector}")
                if sum(binary_vector) == 0:
                    finalResponse = "I couldn't identify any specific symptoms from before. Could you describe your health concerns again?"
                else:
                    diseasesPredicted = predict_disease(binary_vector)
                    profile = get_user_profile(current_user["id"])
                    raw_adjust_response = askGemini(
                        f"Disease: {diseasesPredicted}, Symptoms: {pending_symptoms}, Age: {profile['age']}, Gender: {profile['gender']}",
                        geminiAdjustmentChat
                    )
                    print(f"Raw adjustment response: {raw_adjust_response}")
                    try:
                        adjustments = json.loads(raw_adjust_response)
                    except json.JSONDecodeError:
                        adjustments = {"disease_adjustment": "None", "medicine_adjustment": "None"}
                    ayurvedicRog = classifyDisease(diseasesPredicted, pending_symptoms, geminiAryuvedicChat).strip()
                    listOfAyurvedicMedication = getKeyValuesfromMedicineJson(aryuvedicMedicineData, ayurvedicRog)
                    if not isinstance(listOfAyurvedicMedication, list):
                        listOfAyurvedicMedication = listCleaner(listOfAyurvedicMedication)
                    
                    userMedicalData = (
                        f"Disease Name: {diseasesPredicted}\n"
                        f"Symptoms: {pending_symptoms}\n"
                        f"Age: {profile['age'] or 'Not provided'}\n"
                        f"Gender: {profile['gender'] or 'Not provided'}\n"
                        f"Disease Adjustment: {adjustments.get('disease_adjustment', 'None')}\n"
                        f"Medicine Adjustment: {adjustments.get('medicine_adjustment', 'None')}\n"
                        f"Ayurvedic Disease Name: {ayurvedicRog}\n"
                        f"Ayurvedic Medications List: {listOfAyurvedicMedication}"
                    )
                    finalResponse = askGemini(userMedicalData, geminiFinalResponseChat)
            else:
                finalResponse = "Thanks for sharing! If you have any health concerns, please describe them."
        else:  # symptoms
            # Parse symptoms, age, gender
            raw_response = askGemini(data.user_input, geminiDiseaseChat)
            print(f"Raw Gemini response (symptoms): {raw_response}")
            try:
                parsed_data = json.loads(raw_response)
                if not isinstance(parsed_data, dict):
                    raise ValueError("Invalid JSON structure")
                print(f"Parsed data: {parsed_data}")
            except (json.JSONDecodeError, ValueError) as e:
                print(f"JSON parsing error (symptoms): {str(e)}")
                finalResponse = "I couldn’t process that input. Could you describe your symptoms again?"
                parsed_data = {"symptoms": [], "age": None, "gender": None}
            
            symptoms = parsed_data.get("symptoms", [])
            age = parsed_data.get("age")
            gender = parsed_data.get("gender")
            
            print(f"Extracted symptoms: {symptoms}")
            if age is not None or gender is not None:
                save_user_profile(current_user["id"], age, gender)
                print(f"Saved profile: age={age}, gender={gender}")
            
            if not symptoms or all(s.strip() == "" for s in symptoms):
                finalResponse = "I couldn't identify any specific symptoms. Could you describe your health concerns in more detail?"
            else:
                profile = get_user_profile(current_user["id"])
                if not (profile["age"] or profile["gender"]):
                    save_pending_chat(current_user["id"], symptoms)
                    finalResponse = "To provide a more accurate diagnosis, could you share your age and gender? (e.g., 'I’m 30 male')"
                else:
                    binary_vector = convertUserResponseToDatasetStructure(symptoms, symptom_master_list)
                    print(f"Symptoms binary vector: {binary_vector}")
                    if sum(binary_vector) == 0:
                        finalResponse = "I couldn't match those symptoms with our database. Could you describe them differently?"
                    else:
                        diseasesPredicted = predict_disease(binary_vector)
                        raw_adjust_response = askGemini(
                            f"Disease: {diseasesPredicted}, Symptoms: {symptoms}, Age: {profile['age']}, Gender: {profile['gender']}",
                            geminiAdjustmentChat
                        )
                        print(f"Raw adjustment response: {raw_adjust_response}")
                        try:
                            adjustments = json.loads(raw_adjust_response)
                        except json.JSONDecodeError:
                            adjustments = {"disease_adjustment": "None", "medicine_adjustment": "None"}
                        ayurvedicRog = classifyDisease(diseasesPredicted, symptoms, geminiAryuvedicChat).strip()
                        listOfAyurvedicMedication = getKeyValuesfromMedicineJson(aryuvedicMedicineData, ayurvedicRog)
                        if not isinstance(listOfAyurvedicMedication, list):
                            listOfAyurvedicMedication = listCleaner(listOfAyurvedicMedication)
                        
                        userMedicalData = (
                            f"Disease Name: {diseasesPredicted}\n"
                            f"Symptoms: {symptoms}\n"
                            f"Age: {profile['age'] or 'Not provided'}\n"
                            f"Gender: {profile['gender'] or 'Not provided'}\n"
                            f"Disease Adjustment: {adjustments.get('disease_adjustment', 'None')}\n"
                            f"Medicine Adjustment: {adjustments.get('medicine_adjustment', 'None')}\n"
                            f"Ayurvedic Disease Name: {ayurvedicRog}\n"
                            f"Ayurvedic Medications List: {listOfAyurvedicMedication}"
                        )
                        finalResponse = askGemini(userMedicalData, geminiFinalResponseChat)
        
        # Save bot response
        conn = sqlite3.connect("ayurvaid.db")
        cursor = conn.cursor()
        cursor.execute(
            "INSERT INTO chats (user_id, sender, message) VALUES (?, ?, ?)",
            (current_user["id"], "bot", finalResponse)
        )
        conn.commit()
        conn.close()
        
        return {"response": finalResponse}
    
    except Exception as e:
        print(f"Unexpected error: {str(e)}")
        return {"error": f"Error processing request: {str(e)}"}
# Chat history endpoint
@app.get("/chats", response_model=List[ChatMessage])
async def get_chat_history(current_user: dict = Depends(get_current_user)):
    conn = sqlite3.connect("ayurvaid.db")
    cursor = conn.cursor()
    cursor.execute(
        "SELECT sender, message, timestamp FROM chats WHERE user_id = ? ORDER BY timestamp ASC",
        (current_user["id"],)
    )
    chats = cursor.fetchall()
    conn.close()
    
    return [
        {"sender": chat[0], "message": chat[1], "timestamp": chat[2]}
        for chat in chats
    ]